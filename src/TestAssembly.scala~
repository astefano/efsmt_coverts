package org

import parma_polyhedra_library._

//for parsing
import scala.util.parsing.combinator.PackratParsers
import scala.util.parsing.combinator.RegexParsers
import scala.util.parsing.combinator._

import scala.util.matching.Regex

//options parser
import scopt._

object PTA2EF extends ZoneGraphVV {

  def getBit(x: Int, i: Int) = if ((x & (1 << i)) != 0) 1 else 0

  def encodeLocs(ta: TA) = {
    val locs = getLocs(ta).toList.sorted
    val name = getName(ta)
    val defaultlocname = "l" + name
    val n = locs.length

    if (n == 2) {
      (Map((locs(0) -> ("!"+defaultlocname)), (locs(1) -> defaultlocname)), 
       Set(defaultlocname))
    }
    else {
      var nlocs = Set[String](defaultlocname+"0", defaultlocname+"1")
      val map2 = Map[Location, Location]((locs(0), "!"+defaultlocname+"0 && !" +defaultlocname+"1"), 
					 (locs(1), defaultlocname+"0 && !" +defaultlocname+"1"))
      val maplocs = List.range(2, n).map{
	i =>
	  var is = i
	var pos = 0
	var encode = ""
	while (is > 0) {
	  val bit = is & (1 << 0)
	  val neg = if (bit != 0) "" else "!"
	  encode +=  neg + defaultlocname + pos + " && "
	  nlocs += defaultlocname + pos
	  is = is >> 1
	  pos += 1
	}
	((locs(i) -> encode.dropRight(4).trim))
      } ++ map2

      (maplocs.toMap, nlocs)
    }
  }

  def main(args: Array[String]) {

    val modelPath = wd + "Imitator/Philos2"
    try {
      val dir = new java.io.File(modelPath)    
      dir.listFiles.filter(f => !f.isDirectory).map(f => f.toString).filter(fs => fs.endsWith(".imi")).toList.map{
	file => 
	val out = runImitator(file) 
	outEF += "\n" + imiDecl2EFDecl(nfile) + "\n\n" + states2CIEF(out)
      }
    }  


  }
}


